name,ring,quadrant,isNew,description
ASP.NET Minimal APIs,Adopt,languages & frameworks,FALSE,"<p>A lightweight successor to Controller classes. ASP.NET Minimal APIs provide a more declarative syntax for web applications, allowing for more inline code, a reduction in boilerplate code and smaller projects.</p>
<p>It was noted that the brevity of ASP.NET Minimal APIs leads to some of the implementation detail being hidden, making it harder in some cases to follow and debug the API code.</p>
<p>These are now in broad use at the RSC.</p>"
Blazor,Hold,languages & frameworks,FALSE,"<p>Blazor is a framework for building interactive Web applications using .NET, with the option to compile to WebAssembly to run code in the browser.</p>
<p>One of our internal applications uses Blazor in the front end, but the team preferred the developer experience of building UIs in Vue, which remains our first choice for front ends. The team also encountered more connectivity issues with the Blazor-based app than they would expect for an equivalent Vue app.</p>
<p>The team acknowledged that there could be edge cases in which Blazor would be a compelling choice, for example where it's useful to be able to use the same .NET types across the front and back end.</p>
<p>With this in mind, and with its relatively small developer community, we'd be unlikely to move to Blazor for UI development.</p>"
GraphQL,Assess,languages & frameworks,FALSE,"<p>GraphQL is a query language and runtime that enables API clients to request specific data from a server by defining the structure of the desired response.</p>
<p>It is well suited to large and complex data structures, where its declarative operations can make API calls more efficient than REST. However, it can be hard to use effectively when object graph sizes are unpredictable, and may be overly complex for simple queries. Salesforce uses a graph-based API, but it is not GraphQL.</p>
<p>Compared to REST, GraphQL requires greater engineering effort to implement on the server side, particularly when supporting partial object updates. While some vendors like New Relic may offer GraphQL-style APIs, we are not currently planning to offer GraphQL services ourselves, as our current use cases do not justify the complexity involved.</p>"
NuxtJS,Trial,languages & frameworks,FALSE,<p>See: <i>server-side prerendering</i>.</p>
Playwright (for back-end/C#),Hold,languages & frameworks,TRUE,"<p>A headless browser testing framework and analysis tool developed by Microsoft.</p>
<p>Compared to our existing frameworks, Playwright is relatively simple to use, performs well in GitHub Actions, and suffers from fewer driver/browser compatibility issues. It supports features like temporal testing, cookie handling, API testing, and WebSocket testing.</p>
<p>However, the C#/.NET experience isn't as mature as the JavaScript offering. The test team has begun migrating to Playwright but encountered familiar issues such as timing problems similar to those seen with Selenium. As a result, the experience has not been as positive for testers as it has been for front-end developers.</p>"
Playwright (for front end/JS),Adopt,languages & frameworks,TRUE,"<p>A headless browser testing framework and analysis tool developed by Microsoft.</p>
<p>Playwright is being used increasingly in front-end development, with strengths including API mocking, visual testing, and good support for accessibility features. It runs reliably in GitHub Actions and offers strong support for temporal testing and cookie handling.</p>
<p>The JavaScript interface is more mature than the .NET version and benefits from an active community and new AI-assisted tooling. Debugging is particularly strong, with the ability to download and locally inspect traces. Tooling is available to scaffold tests from recorded sessions, and Visual Studio Code extensions further improve developer experience.</p>"
Preact,Hold,languages & frameworks,TRUE,"<p>A lightweight JavaScript UI framework based on React.</p>
<p>We're watching the development of preact and may choose to run trials with it in the future, but with a relatively small developer community compared to Vue, we don't see a compelling reason to use it at this stage.</p>"
Puppeteer,Hold,languages & frameworks,FALSE,"<p>A NodeJS library for headless browser automation and UI testing.</p>
<p>Puppeteer was used in some earlier projects and initially explored as an alternative to Selenium. While it showed promise, we encountered issues related to ChromeDriver stability and have since transitioned to Playwright for better reliability and developer experience. It is no longer actively used in new projects.</p>"
React,Hold,languages & frameworks,FALSE,"<p>An open-source JavaScript library for building UIs.</p>
<p>We have discussed UI framework choices at length and have run parallel spikes as part of an assessment to determine our preferred choice. While React has the largest user community, we found VueJS slightly easier to work with and we already have Vue applications in our estate. Based on our investigation, we found it unlikely we'd encounter a use case that would warrant switching to React, but it remains the most popular JavaScript framework for UI development.</p>"
Sass,Assess,languages & frameworks,FALSE,"<p>A preprocessor scripting language that extends CSS with features like variables, nested rules, and mixins.</p>
<p>Its relevance is decreasing as modern CSS continues to adopt similar features natively. Additionally, since our UI component library is built with Tailwind, using Sass in most projects would add unnecessary complexity. That said, Sass may still be considered for legacy systems or isolated cases where Tailwind is not in use.</p>"
Tailwind CSS,Adopt,languages & frameworks,TRUE,"<p>A utility-first CSS framework that provides low-level classes to build custom designs directly in HTML.</p>
<p>Tailwind helps reduce CSS bloat and improves maintainability by encouraging developers to focus on HTML structure. It works well with Vue and the shared component library, supports responsive design via design tokens, and has strong support for prototyping and scaling UI systems. Tailwind v4 was released recently, further improving the developer experience. The bundle size is compact, and the framework is backed by a very active community, regular NPM updates, and excellent documentation.</p>"
TypeScript,Trial,languages & frameworks,FALSE,"<p>A typed superset of JavaScript that compiles to plain JavaScript, offering static type checking and improved tooling support.</p>
<p>TypeScript is increasingly prevalent in the UI frameworks we use, including Vue 3, where it works particularly well with the Composition API—the current standard for building reusable and maintainable components. While we have traditionally preferred JavaScript with JSDoc for its simplicity and compatibility, TypeScript offers guardrails that can benefit shared component development.</p>
<p>It remains incompatible with some tools (e.g. AVA), and introduces complexity that should be weighed carefully. However, given its growing ecosystem support and successful usage in projects like the Submission UI, we are trialling its adoption in selected front-end components and libraries.</p>"
VueJS,Adopt,languages & frameworks,FALSE,"<p>Vue is our preferred framework on the basis of its ease of use, its large user community, the benefit of existing in-house experience and its support for server prerendering through Nuxt.</p>"
AWS Fargate,Adopt,platforms,FALSE,"<p>AWS Fargate provides container hosting without the need to manage the host OS. Fargate tasks can be run ad-hoc, on a schedule, based on a trigger, or as a 24/7 service, which makes it an attractive option for workloads that are too large for Lambda execution, or that would otherwise require an EC2 instance.</p>"
.NET Core microservices,Adopt,techniques,TRUE,"<p>We typically use this term to refer to Lambda functions that directly use API Gateway APIs for .NET, with the C# project generated using the AWS Lambda project template. For microservices implementations, this has an advantage over <i>Serverless ASP.NET</i> because Lambda functions map directly to .NET methods, whereas in <i>Serverless ASP.NET</i>, the Lambda function is a wrapper around an HTTP service that has its own request mapping logic. However, deployment of these services tends to take more work because each function needs its own route in API Gateway, and it's harder to launch the project locally as an HTTP service for debugging.</p>
<p>Newer projects such as the Resource APIs use this approach.</p>"
Blue/green deployments,Trial,techniques,FALSE,"<p>Well suited to UI-centric applications where continuity of service is important and in scenarios where two versions of an application can't be hosted simultaneously, but maintaining two live environments is costly. Special care and planning is needed for data stores, especially where RDBMS schema changes are needed between deployments.</p>
<p>We would tend not to consider a blue/green deployment strategy. However, we <i>do</i> use a version of it for our OpenSearch indexes and mappings.</p>"
GitHub Flow,Adopt,techniques,FALSE,"<p>GitHub Flow helps to streamline code review by encapsulating changes within pull requests.</p>
<p>The pull request review process is particularly beneficial for quality assurance, especially in teams handling multiple projects. It is favored by our outsourced development partners as it provides a consolidated point of documentation for features that may consist of multiple commits.</p>
<p>A drawback is that feature branches can linger, leading to larger and more complex merge conflicts, which can hinder the 'Push on Green' strategy. We ultimately aim to build confidence in our CI/CD process to a level where pull requests become unnecessary.</p>"
Push on Green,Adopt,techniques,FALSE,"<p>We think of Push on Green to mean that code and configuration changes are deployed with some level of automation provided all tests pass. Deployment can be gated on manual verification. Highly dependent on comprehensive, good-quality test coverage, good review processes and confidence in the team's ability to deliver low-defect software.</p>
<p>We use this technique in some but not all projects, and find it easier to implement for back-end and non-UI applications as it's harder to catch visual regressions with automated tests, although feature flags and A/B tests can help to mitigate this. We don't use it for Terraform. We find it important to have a clear definition of &quot;green&quot; when applying this technique.</p>
<p>Proceed with caution for applications with complex or in-flux UI testing needs as UI test automation tends to take a disproportionate amount of effort and maintenance.</p>
<p>Applications composed of multiple deployable components may not be well suited to this technique, for example an application where the UI and a set of back-end microservices are independently deployed.</p>
<p>There should be a distinction between critical, core functionality vs. features that can be broken short-term so that new, non-critical features can be deployed rapidly, even if incomplete. Support for this technique really needs to be built in from the start, so we would typically not consider migrating established applications to a Push on Green pipeline.</p>"
Rolling deployments,Adopt,techniques,FALSE,"<p>We define rolling deployments as a process for deploying new versions of an application to a subset of instances, ensuring a seamless update without disrupting the overall service. This technique is particularly useful when we have control over the running instances of the application, such as with EC2 and ECS. We use this approach in the Librarian workstream. We don't use it for AWS Lambda deployments.</p>
<p>We think of this approach as being similar to the blue/green deployment strategy, but it differs in that it doesn't involve duplicating the entirety of the infrastructure, including databases.</p>"
Server side prerendering (e.g. Nuxt),Adopt,techniques,FALSE,"<p>A technique supported by frameworks such as Nuxt.js and Blazor that allows routes in a single-page app to be handled and rendered on the server.</p>
<p>For sites that require SEO, it's important to use a framework that supports this. Some key advantages over purely browser-based SPAs are:</p>
<ul><li>Improved SEO over single-page apps as search engines can crawl fast, pre-rendered and cacheable pages with the right meta tags.</li>
<li>Fast page load times from deep links as we're able to deliver a fully-rendered page with edge caching for frequently-accessed content.</li>
<li>The browser can switch the page to a single-page app as soon as the additional UI code had loaded, providing a seamless transition to single-page app user experience.</li></ul>"
"Serverless ASP.NET
(lambda)",Trial,techniques,FALSE,"<p>ASP.NET Core applications can be deployed as AWS Lambda functions for serverless operation.</p>
<p>Useful for migrating services from VMs and EC2 into serverless infrastructure. Cold start times can cause high latency for some requests, but there are mitigations for this.</p>
<p>When compared to <i>ASP.NET Core microservices</i>, this approach can have advantages. As the URI routing is handled internally, multiple endpoints can be exposed through a single API Gateway route with wildcards, making deployments simpler.</p>"
Amazon Aurora,Assess,tools,FALSE,"<p>An RDBMS service provided by Amazon that offers compatibility with MySQL and PostgreSQL, with improved performance and availability over standard open-source deployments.</p>
<p>There can be significant cost savings compared to SQL Server in AWS, and Aurora Serverless adds flexibility by enabling automatic scaling and some maintenance operations without downtime. These uptime advantages are particularly appealing for applications requiring high availability.</p>
<p>While our existing expertise with SQL Server remains a factor, a 2023 evaluation suggested that PostgreSQL would be our preferred engine if we adopt Aurora. Aurora is a strong candidate for greenfield projects and cloud-native workloads where licensing cost, scalability, or availability are key considerations.</p>"
Browserstack,Hold,tools,FALSE,"<p>A cloud-based, cross-browser testing platform used to test and debug web applications on various browsers and devices in real-time.</p>
<p>Our use of this service is diminishing as we've found other tools like Playwright to be a much better fit for us, but it's useful for testing specific edge cases involving unique browser and platform combinations. It's also very useful to be able to test with a variety of devices and form factors, especially phones.</p>"
Docker Desktop,Adopt,tools,FALSE,"<p>A desktop Docker engine with Linux and Windows virtualization support, useful for local container development and debugging.</p>
<p>We use Docker Desktop in scenarios such as container-based development with Devcontainers, local debugging, and when setting up Fargate containers. It is especially helpful when authoring and testing Dockerfiles intended for deployment in our pipelines. However, it is not currently one of our default developer tools and is used on a case-by-case basis.</p>"
MongoDB,Assess,tools,FALSE,"<p>A NoSQL database management system that is well suited to running complex queries and aggregations over large, unstructured data sets. Supports JSON and BSON. Amazon DocumentDB is compatible with MongoDB.</p>
<p>Although a well-established technology, we haven't recently identified any use cases where it would be particularly advantageous to us. We began developing with MongoDB in 2022 on the basis that Amazon DocumentDB would be compatible, but in practice we found that DocumentDB didn't fully support the API features expected by the .NET drivers for MongoDB, which hampered our work and led to switching to another technology. Amazon now offers good .NET support for DocumentDB.</p>"
MSSQL,Adopt,tools,FALSE,"<p>SQL Server has been our default RDBMS for many years. We have extensive in-house experience with SQL Server and it has high-quality supporting tools. It is supported in Amazon RDS but is expensive compared to other options such as Aurora, and SQL Server Cartridges are not supported in RDS.</p>
<p>We don't see a compelling need to migrate applications away from SQL Server, but we would consider other options for new projects, especially the Aurora engines in AWS.</p>"
Storybook,Adopt,tools,FALSE,"<p>An open-source tool suite for building, testing, accessibility checking and documenting shared UI components.</p>
<p>Storybook has helped us to build rich documentation and visualisation around our UI component library. Good integration with Frontify. It has a large set of capabilities we have yet to explore, including automated testing, user workflows and prototyping tools.</p>"
Code Rabbit,Assess,tools,TRUE,"<p>An AI-powered tool focused on automated code review rather than code generation.</p>
<p>Code Rabbit offers AI assistance during the review process, helping to highlight issues, suggest improvements, and support reviewer productivity. While useful, its features are not unique and are likely to be offered through more widely adopted platforms such as GitHub Copilot in the near future.</p>"
GitHub Copilot,Assess,tools,TRUE,"<p>An AI-powered coding assistant integrated into Visual Studio and VS Code, designed to suggest code completions, generate boilerplate, and assist with development tasks.</p>
<p>Copilot offers good IDE integration and can accelerate development workflows, but comes with challenges including variable pricing, code hallucinations, and inconsistent output quality. For more in-depth queries, we’ve often found that ChatGPT provides better answers. Its usefulness may depend on individual developer workflow and tolerance for occasional inaccuracies.</p>"
Continue.dev,Trial,tools,TRUE,"<p>An open-source AI coding assistant. Integrates well with Visual Studio Code.</p>
<p>Flexible in terms of which language models can be used. No support for full Visual Studio though.</p>"
Amazon DocumentDB,Assess,tools,TRUE,"<p>Amazon DocumentDB is a fully managed, scalable, and highly available document database service that is compatible with MongoDB. It is designed to handle JSON workloads efficiently. Our work with DocumentDB was held back by .NET libary support (see <i>MongoDB</i>), but the situation is much improved now.</p>
<p>Currently there is no serverless offering for DocumentDB, which makes it a much less compelling choice for us than an alternative like DynamoDB, S3 or an Aurora engine.</p>"
